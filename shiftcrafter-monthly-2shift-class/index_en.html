<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ShiftCrafter Part 6 — Class-Based & Matrix View</title>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            margin: 24px;
            color: #0e1d2f;
        }

        h1 {
            margin: 0 0 12px;
            font-size: 22px;
        }

        .desc {
            color: #456;
            margin-bottom: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .panel {
            border: 1px solid #dde3ea;
            border-radius: 10px;
            padding: 12px;
            background: #f8fafc;
        }

        .panel h2 {
            font-size: 16px;
            margin: 0 0 8px;
            border-bottom: 1px solid #eef2f7;
            padding-bottom: 4px;
        }

        label {
            display: block;
            font-size: 12px;
            color: #345;
            margin: 6px 0 4px;
            font-weight: 500;
        }

        input,
        textarea,
        select,
        button {
            width: 100%;
            box-sizing: border-box;
            font-size: 13px;
            padding: 6px 8px;
            border: 1px solid #c9d3df;
            border-radius: 6px;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .row>* {
            flex: 1;
        }

        .btn {
            background: #0ea5a6;
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 8px;
        }

        .btn.secondary {
            background: #475569;
        }

        .btn:disabled {
            opacity: .6;
            cursor: not-allowed;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            white-space: nowrap;
        }

        th,
        td {
            border: 1px solid #e2e8f0;
            padding: 4px 6px;
            text-align: center;
        }

        th {
            background: #eef2f7;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .note {
            font-size: 11px;
            color: #678;
        }

        .ok {
            color: #0a7;
            font-weight: 600;
        }

        .error {
            color: #b91c1c;
            font-weight: 600;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        }

        /* Shift symbols colors */
        .sym-night {
            color: #b45309;
            font-weight: bold;
            background-color: #fff7ed;
        }

        .sym-post {
            color: #64748b;
            background-color: #f1f5f9;
        }

        .sym-off {
            color: #94a3b8;
        }

        .sym-day {
            color: #0e1d2f;
        }
    </style>
</head>

<body>
    <h1>ShiftCrafter Part 6 — Class-Based & Matrix View</h1>
    <p class="desc">
        Supports <b>Class (A/B)</b>, <b>Detailed Requests</b> (Day/Night/Off/NoNight), and <b>Weekday/Holiday</b>
        settings.<br>
        Exports in <b>Matrix CSV</b> format.
    </p>

    <div class="grid">
        <div class="panel">
            <h2>Settings</h2>
            <label>Target Month (YYYY-MM)</label>
            <input id="month" type="month" value="2026-01" />

            <div class="row">
                <div>
                    <label>Need Day (Weekday)</label>
                    <input id="needDayWeekday" type="number" min="0" value="3" />
                </div>
                <div>
                    <label>Need Day (Weekend/Hol)</label>
                    <input id="needDayHoliday" type="number" min="0" value="2" />
                </div>
            </div>
            <div class="row">
                <div>
                    <label>Need Night (Daily)</label>
                    <input id="needNight" type="number" min="0" value="2" />
                </div>
                <div>
                    <label>Need Early / Late</label>
                    <div class="row">
                        <input id="needEarly" type="number" min="0" value="1" placeholder="Ear" title="Early Need" />
                        <input id="needLate" type="number" min="0" value="1" placeholder="Lat" title="Late Need" />
                    </div>
                </div>
            </div>

            <div class="row">
                <div>
                    <label>Min Class A (Day)</label>
                    <input id="minClassADay" type="number" min="0" value="1" />
                </div>
                <div>
                    <label>Min Class A (Day) (Holiday)</label>
                    <input id="minClassADayHoliday" type="number" min="0" value="1" />
                </div>
                <div>
                    <label>Min Class A (Night)</label>
                    <input id="minClassANight" type="number" min="0" value="1" />
                </div>
            </div>

            <div class="row">
                <div>
                    <label>Monthly Night Cap (Normal)</label>
                    <input id="monthlyNightCap" type="number" min="0" placeholder="(Optional)" />
                </div>
                <div>
                    <label>Monthly Night Cap (Short/S)</label>
                    <input id="monthlyNightCapShort" type="number" min="0" value="0" placeholder="0 for No Night" />
                </div>
            </div>

            <label>Holidays (YYYY-MM-DD) <span class="note">*Sat/Sun are auto-detected</span></label>
            <textarea id="holidays" placeholder="2026-11-03\n2026-11-23" style="min-height:50px;"></textarea>

            <h2>Staff & Requests</h2>
            <label>Staff List (Name:Class:S) <span class="note">A=Leader, B=General, :S=Short</span></label>
            <textarea id="staffList" placeholder="Smith:A\nJohnson:B\nDavis:B:S"></textarea>

            <label>Requests (Date Name Type) <span class="note">Type: Off, Day, Night, NoNight</span></label>
            <textarea id="requests"
                placeholder="2026-01-03 Smith Off\n2026-01-05 Johnson Night\n2026-01-10 Williams NoNight"></textarea>

            <button class="btn" id="btnGen">Generate Schedule</button>
            <div id="msg" class="note" style="margin-top:8px;"></div>
        </div>

        <div class="panel">
            <h2>Preview</h2>
            <div class="row">
                <button class="btn secondary" id="btnCsv" disabled>Matrix CSV</button>
                <button class="btn secondary" id="btnIcs" disabled>ICS</button>
                <button class="btn secondary" id="btnReport" disabled>Verification Report</button>
            </div>

            <div id="tableWrap" style="margin-top:10px; overflow-x:auto;">(Not Generated)</div>
            <pre id="reportArea"
                style="background:#fff; padding:8px; border:1px solid #ccc; max-height:200px; overflow:auto; margin-top:10px; font-size:12px;"></pre>

            <div class="footer note">
                Symbols: <span class="sym-day">Space=Day</span>, <span class="sym-night">N=Night</span>, <span
                    class="sym-post">P=Post-Night</span>, <span class="sym-off">/=Off</span>, E=Early, L=Late<br>
                Priority: Fixed Requests > Night Assignment > Early/Late > Day Fill<br>
                *Day after Night shift is automatically Post-Night (P) or Off (/).
            </div>
        </div>
    </div>

    <script>
        // --- Utils ---
        const fmtDate = d => d.toISOString().slice(0, 10);
        const parseDate = s => new Date(s);
        const addDays = (d, n) => { const x = new Date(d); x.setDate(x.getDate() + n); return x; };
        const getDayNum = d => d.getDay(); // 0=Sun, 6=Sat

        // --- Input Parsing ---
        function getVal(id, def = 0) {
            const v = document.getElementById(id).value;
            if (v === '') return def;
            const n = Number(v);
            return isNaN(n) ? def : n;
        }
        function getText(id) { return document.getElementById(id).value.trim(); }

        function parseStaff(text) {
            // Format: "Name:Class" or JSON ["Name:Class", ...]
            if (text.startsWith('[')) {
                try { const arr = JSON.parse(text); if (Array.isArray(arr)) return arr.map(parseStaffLine); } catch (e) { }
            }
            return text.split(/\n+/).map(s => s.trim()).filter(Boolean).map(parseStaffLine);
        }
        function parseStaffLine(line) {
            // Name:Class:Option
            const parts = line.split(':');
            const name = parts[0].trim();
            let cls = 'B';
            let isShort = false;

            for (let i = 1; i < parts.length; i++) {
                const p = parts[i].trim().toUpperCase();
                if (p === 'A') cls = 'A';
                else if (p === 'B') cls = 'B';
                else if (p === 'S') isShort = true;
            }
            return { name, class: cls, isShort };
        }

        function parseRequests(text) {
            // Format: "YYYY-MM-DD Name Type"
            const map = {};
            const add = (d, n, t) => {
                if (!map[d]) map[d] = {};
                map[d][n] = t; // 'Off', 'Day', 'Night', 'NoNight'
            };

            if (text.startsWith('[')) {
                try {
                    const arr = JSON.parse(text);
                    arr.forEach(r => add(r.date, r.name, normalizeReqType(r.type)));
                    return map;
                } catch (e) { }
            }

            text.split(/\n+/).forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length < 2) return;
                const date = parts[0];
                const name = parts[1];
                const rawType = parts[2] || 'Off';
                add(date, name, normalizeReqType(rawType));
            });
            return map;
        }

        function normalizeReqType(t) {
            if (!t) return 'Off';
            const s = String(t).toLowerCase();
            if (['day', 'd', '日'].includes(s)) return 'Day';
            if (['night', 'n', '夜'].includes(s)) return 'Night';
            if (['nonight', 'no-night', 'xn', '×夜'].includes(s)) return 'NoNight';
            return 'Off';
        }

        function parseHolidays(text) {
            const s = new Set();
            text.split(/\n+/).forEach(line => s.add(line.trim().split(/\s+/)[0]));
            return s;
        }

        // --- Logic (Same algo as JP) ---
        function generateSchedule() {
            const monthStr = document.getElementById('month').value;
            if (!monthStr) return alert("Please select a target month.");

            const startDate = new Date(monthStr + "-01");
            const endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
            const daysInMonth = endDate.getDate();

            // Settings
            const reqDayWk = getVal('needDayWeekday', 3);
            const reqDayHol = getVal('needDayHoliday', 2);
            const reqNight = getVal('needNight', 2);
            const reqEarly = getVal('needEarly', 1);
            const reqLate = getVal('needLate', 1);

            const minClassADay = getVal('minClassADay', 1);
            const minClassADayHoliday = getVal('minClassADayHoliday', 1);
            const minClassANight = getVal('minClassANight', 1);

            const capMo = (document.getElementById('monthlyNightCap').value === '') ? 999 : getVal('monthlyNightCap', 999);
            const capMoShort = getVal('monthlyNightCapShort', 0);

            // Data
            const staffList = parseStaff(getText('staffList'));
            const requests = parseRequests(getText('requests'));
            const holidays = parseHolidays(getText('holidays'));

            if (staffList.length === 0) return alert("Please enter staff list.");

            // Calculate Target Off Days (Month Days - (Sat+Sun+Holidays))
            let weHolCount = 0;
            for (let i = 1; i <= daysInMonth; i++) {
                const d = new Date(startDate.getFullYear(), startDate.getMonth(), i);
                const dayOfWeek = d.getDay();
                const dateStr = fmtDate(d);
                if (dayOfWeek === 0 || dayOfWeek === 6 || holidays.has(dateStr)) {
                    weHolCount++;
                }
            }
            const maxWorkDays = daysInMonth - weHolCount;

            // Init State
            const schedule = [];
            const stats = {};
            staffList.forEach(s => {
                stats[s.name] = {
                    total: 0, nightMonth: 0,
                    class: s.class,
                    isShort: s.isShort,
                    history: []
                };
            });

            // Loop Days
            for (let i = 1; i <= daysInMonth; i++) {
                const d = new Date(startDate.getFullYear(), startDate.getMonth(), i);
                const dateStr = fmtDate(d);
                const dayOfWeek = d.getDay();
                const isHol = (dayOfWeek === 0 || dayOfWeek === 6) || holidays.has(dateStr);

                // Day Requirements
                const targetDay = isHol ? reqDayHol : reqDayWk;
                const targetClassADay = isHol ? minClassADayHoliday : minClassADay;
                const targetNight = reqNight;

                // Helper: Calculate consecutive work days (backwards from yesterday)
                const getConsecutive = (name) => {
                    let count = 0;
                    const hist = stats[name].history;
                    for (let k = hist.length - 1; k >= 0; k--) {
                        const type = hist[k];
                        if (type === 'Off') break; // Break only on Off
                        count++;
                    }
                    return count;
                };

                // Helper: Calculate work density in last N days
                const getWorkDensity = (name, days) => {
                    let count = 0;
                    const hist = stats[name].history;
                    for (let k = 1; k <= days; k++) {
                        const idx = hist.length - k;
                        if (idx < 0) break;
                        const type = hist[idx];
                        if (type !== 'Off') count++;
                    }
                    return count;
                };

                // Helper for Leveling
                const sortByWork = (list) => {
                    list.sort((a, b) => {
                        const consA = getConsecutive(a.name);
                        const consB = getConsecutive(b.name);
                        const densA = getWorkDensity(a.name, 7);
                        const densB = getWorkDensity(b.name, 7);

                        const scoreA = (densA * 10) + (consA * 5) + stats[a.name].total;
                        const scoreB = (densB * 10) + (consB * 5) + stats[b.name].total;

                        const diff = scoreA - scoreB;
                        if (Math.abs(diff) > 0.1) return diff;
                        return Math.random() - 0.5; // Randomize ties
                    });
                };

                // Check assignments
                const assignments = { night: [], early: [], late: [], day: [], off: [] };
                const pool = { night: [], day: [] }; // Pool candidates

                staffList.forEach(p => {
                    const name = p.name;
                    const req = requests[dateStr]?.[name];
                    const prevShift = stats[name].history[i - 2];

                    // Rule: Post-Night -> Off
                    if (prevShift === 'Night') {
                        assignments.off.push(name);
                        stats[name].history.push('PostNight');
                        return;
                    }

                    if (req === 'Off') {
                        assignments.off.push(name);
                        stats[name].history.push('Off');
                        return;
                    }
                    if (req === 'Night') {
                        assignments.night.push(name);
                        stats[name].history.push('Night');
                        stats[name].nightMonth++;
                        return;
                    }
                    if (req === 'Day') {
                        assignments.day.push(name);
                        stats[name].history.push('Day');
                        stats[name].total++;
                        return;
                    }

                    // Valid Candidate for Night?
                    const myCap = p.isShort ? capMoShort : capMo;
                    // Check Weekly Cap: Count nights in last 6 days
                    let nightsInWeek = 0;
                    for (let k = 1; k <= 6; k++) {
                        if (stats[name].history[i - 1 - k] === 'Night') nightsInWeek++;
                    }
                    let canNight = req !== 'NoNight' && stats[name].nightMonth < myCap && nightsInWeek < capWk;

                    // Check Tomorrow for Off Request
                    const tmrStr = fmtDate(addDays(d, 1));
                    if (requests[tmrStr]?.[name] === 'Off') {
                        canNight = false;
                    }

                    // Max Work Limit: Count "Consumed Days" = Work(Total) + PostNight
                    const postNightCount = stats[name].history.filter(h => h === 'PostNight').length;
                    const consumedDays = stats[name].total + postNightCount;

                    // Limits
                    // Limits
                    const isMaxWorkStr = consumedDays >= maxWorkDays;
                    const isConsecutiveLimit = getConsecutive(name) >= 3; // Strict 3-day limit

                    // Strict Weekly Off Check: Ensure 2 days off (Sun-Sat)
                    let isWeeklyOffLimit = false;
                    // Count 'Off' in current week (Sun...Yesterday)
                    let offCountInWeek = 0;
                    const hist = stats[name].history;

                    // dayOfWeek: 0(Sun)..6(Sat)
                    // Look back 'dayOfWeek' days.
                    for (let k = 1; k <= dayOfWeek; k++) {
                        const idx = (i - 1) - k;
                        if (idx < 0) break; // Start of month boundary
                        if (hist[idx] === 'Off') offCountInWeek++;
                    }

                    // Days remaining in week (including Today)
                    const daysLeft = 7 - dayOfWeek;
                    const needed = 2 - offCountInWeek;

                    // If we need 2 more, and only 2 days left (Fri), we MUST off today.
                    // If we need 1 more, and only 1 day left (Sat), we MUST off today.
                    if (needed > 0 && daysLeft <= needed) {
                        isWeeklyOffLimit = true;
                    }

                    if (!isMaxWorkStr && !isConsecutiveLimit && !isWeeklyOffLimit) {
                        if (canNight) pool.night.push(p);
                        pool.day.push(p);
                    } else {
                        // Max work days reached
                        assignments.off.push(name);
                        stats[name].history.push('Off');
                    }
                });

                // Fill Night
                const neededN = Math.max(0, targetNight - assignments.night.length);
                if (neededN > 0) {
                    const currentClassACount = assignments.night.filter(n => stats[n].class === 'A').length;
                    const needClassA = Math.max(0, minClassANight - currentClassACount);

                    pool.night.sort((a, b) => {
                        if (needClassA > 0) {
                            if (a.class === 'A' && b.class !== 'A') return -1;
                            if (a.class !== 'A' && b.class === 'A') return 1;
                        }
                        const consA = getConsecutive(a.name);
                        const consB = getConsecutive(b.name);
                        const densA = getWorkDensity(a.name, 7);
                        const densB = getWorkDensity(b.name, 7);

                        const scoreA = (densA * 10) + (consA * 5) + stats[a.name].total;
                        const scoreB = (densB * 10) + (consB * 5) + stats[b.name].total;

                        const diff = scoreA - scoreB;
                        if (Math.abs(diff) > 0.1) return diff;
                        return Math.random() - 0.5;
                    });

                    for (let k = 0; k < neededN; k++) {
                        if (pool.night.length === 0) break;
                        const p = pool.night.shift();
                        pool.day = pool.day.filter(x => x.name !== p.name);
                        assignments.night.push(p.name);
                        stats[p.name].history.push('Night');
                        stats[p.name].total++;
                        stats[p.name].nightMonth++;
                    }
                }

                // Fill Early
                const targetEarly = isHol ? 0 : reqEarly;
                const neededE = Math.max(0, targetEarly - assignments.early.length);
                sortByWork(pool.day); // Balance load
                for (let k = 0; k < neededE; k++) {
                    if (pool.day.length === 0) break;
                    const p = pool.day.shift();
                    assignments.early.push(p.name);
                    stats[p.name].history.push('Early');
                    stats[p.name].total++;
                }

                // Fill Late
                const targetLate = isHol ? 0 : reqLate;
                const neededL = Math.max(0, targetLate - assignments.late.length);
                sortByWork(pool.day); // Re-sort for Late

                for (let k = 0; k < neededL; k++) {
                    if (pool.day.length === 0) break;
                    const p = pool.day.shift();
                    assignments.late.push(p.name);
                    stats[p.name].history.push('Late');
                    stats[p.name].total++;
                }

                // Fill Day
                const currentDayCount = assignments.day.length;
                let neededD = Math.max(0, targetDay - currentDayCount);

                const countA = [...assignments.early, ...assignments.late, ...assignments.day]
                    .filter(n => stats[n].class === 'A').length;
                let needA = Math.max(0, targetClassADay - countA);

                pool.day.sort((a, b) => {
                    if (needA > 0) {
                        if (a.class === 'A' && b.class !== 'A') return -1;
                        if (a.class !== 'A' && b.class === 'A') return 1;
                    }
                    const consA = getConsecutive(a.name);
                    const consB = getConsecutive(b.name);
                    const densA = getWorkDensity(a.name, 7);
                    const densB = getWorkDensity(b.name, 7);

                    const scoreA = (densA * 10) + (consA * 5) + stats[a.name].total;
                    const scoreB = (densB * 10) + (consB * 5) + stats[b.name].total;

                    const diff = scoreA - scoreB;
                    if (Math.abs(diff) > 0.1) return diff;
                    return Math.random() - 0.5;
                });

                while (neededD > 0 && pool.day.length > 0) {
                    const p = pool.day.shift();
                    assignments.day.push(p.name);
                    stats[p.name].history.push('Day');
                    stats[p.name].total++;
                    if (p.class === 'A') needA--;
                    neededD--;
                }

                // Remaining -> Off
                pool.day.forEach(p => {
                    assignments.off.push(p.name);
                    stats[p.name].history.push('Off');
                });

                schedule.push({
                    date: dateStr,
                    dow: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek],
                    assignments
                });
            } // end loop

            renderMatrix(schedule, staffList, stats, holidays, requests);
            window.lastResult = { schedule, staffList, stats, holidays, requests }; // Added requests to lastResult

            document.getElementById('btnCsv').disabled = false;
            document.getElementById('btnIcs').disabled = false;
            document.getElementById('btnReport').disabled = false;
            document.getElementById('msg').innerHTML = '<span class="ok">Generated!</span>';
        }

        // --- Report ---
        function showReport() {
            if (!window.lastResult) return;
            const { schedule, staffList, stats, holidays, requests } = window.lastResult;

            let log = "";
            let missCount = 0;

            schedule.forEach(day => {
                const date = day.date;
                staffList.forEach(s => {
                    const name = s.name;
                    const req = requests[date]?.[name];

                    // Find what was assigned
                    let assigned = 'Off'; // Default matching logic
                    if (day.assignments.night.includes(name)) assigned = 'Night';
                    else if (day.assignments.early.includes(name)) assigned = 'Day';
                    else if (day.assignments.late.includes(name)) assigned = 'Day';
                    else if (day.assignments.day.includes(name)) assigned = 'Day';
                    else assigned = 'Off';

                    if (req) {
                        let ok = false;
                        let assignedType = assigned === 'Night' ? 'Night' : (assigned === 'Off' ? 'Off' : 'Day');
                        if (req === 'Off' && assignedType === 'Off') ok = true;
                        if (req === 'Day' && assignedType === 'Day') ok = true;
                        if (req === 'Night' && assignedType === 'Night') ok = true;
                        if (req === 'NoNight' && assignedType !== 'Night') ok = true;

                        if (!ok) {
                            log += `[Unfulfilled] ${date} ${name}: Req=${req} -> Res=${assignedType}\n`;
                            missCount++;
                        }
                    }
                });
            });

            if (missCount === 0) log += "All requests fulfilled!\n";
            else log += `\nUnfulfilled Count: ${missCount}\n`;

            // Show Max Work Days status
            log += "\n[Work Days Check]\n";
            const startDate = new Date(schedule[0].date);
            const endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
            const daysInMonth = endDate.getDate();

            // Recalculate target off days for report clarity
            let weHolCount = 0;
            for (let i = 1; i <= daysInMonth; i++) {
                const d = new Date(startDate.getFullYear(), startDate.getMonth(), i);
                const dateStr = fmtDate(d);
                const dayOfWeek = d.getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6 || holidays.has(dateStr)) {
                    weHolCount++;
                }
            }
            const maxWork = daysInMonth - weHolCount;
            log += `Target Off Days (Sat/Sun/Hol): ${weHolCount} (Max Work: ${maxWork})\n`;

            staffList.forEach(s => {
                const total = stats[s.name].total;
                if (total > maxWork) {
                    log += `[Warning] ${s.name}: ${total} days (Over +${total - maxWork})\n`;
                } else {
                    log += `${s.name}: ${total} days (OK)\n`;
                }
            });

            document.getElementById('reportArea').innerText = log;
        }

        // --- Render Matrix ---
        function renderMatrix(schedule, staffList, stats, holidays, requests) {
            const div = document.getElementById('tableWrap');
            let h = '<table><thead><tr><th>Name</th><th>Class</th><th>Sum</th><th>Ni</th><th>Off</th>';

            schedule.forEach(d => {
                const isHol = (d.dow === 'Sun' || d.dow === 'Sat') || holidays.has(d.date);
                const color = isHol ? '#fee' : '#fff';
                h += `<th style="background:${color}" title="${d.date}">${d.date.slice(8)}<br><small>${d.dow}</small></th>`;
            });
            h += '</tr></thead><tbody>';

            staffList.forEach(s => {
                const st = stats[s.name];
                const offCount = st.history.filter(x => x === 'Off').length; // PostNight excluded
                h += `<tr><td style="text-align:left;font-weight:bold;">${s.name}</td><td>${s.class}</td>`;
                h += `<td>${st.total}</td><td>${st.nightMonth}</td><td>${offCount}</td>`;

                st.history.forEach((type, index) => {
                    let sym = '';
                    let cls = '';
                    if (type === 'Night') { sym = 'N'; cls = 'sym-night'; }
                    else if (type === 'PostNight') { sym = 'P'; cls = 'sym-post'; }
                    else if (type === 'Off') { sym = '/'; cls = 'sym-off'; }
                    else if (type === 'Early') { sym = 'E'; cls = 'sym-day'; }
                    else if (type === 'Late') { sym = 'L'; cls = 'sym-day'; }
                    else { sym = ' '; cls = 'sym-day'; } // Day -> ' '

                    // Visualization of Requests
                    // Need date of this col.
                    // st.history is in order of schedule array.
                    const dateStr = schedule[index].date; // index is from for(;;) ?
                    // stats history loop doesn't give index? 
                    // st.history.forEach((type, index) => { ... })
                    // Ah, original code uses forEach(type =>). I need index.

                    const req = requests[schedule[index].date]?.[s.name];
                    if (req) {
                        // Check match
                        // Req: Off, Day, Night, NoNight
                        // Res: N, P, /, E, L, ' '
                        let isMatch = false;
                        if (req === 'Off' && (sym === '/' || sym === 'P')) isMatch = true;
                        if (req === 'Night' && sym === 'N') isMatch = true;
                        if (req === 'Day' && (sym === 'E' || sym === 'L' || sym === ' ')) isMatch = true;
                        // NoNight matches almost anything except N. But NoNight is negative constraint, usually not visualized as "Fulfilled Request" marker?
                        // User asks "Visualize Wishes". NoNight is a wish.
                        // But usually brackets imply "This specific assignment happened because you asked".
                        // NoNight doesn't force a specific assignment.
                        // Let's mark only Positive Matches.

                        if (isMatch) {
                            sym = '[' + sym + ']';
                        }
                    }

                    h += `<td class="${cls}">${sym}</td>`;
                });
                h += '</tr>';
            });
            h += '</tbody></table>';
            div.innerHTML = h;
        }

        // --- CSV ---
        function exportCSV() {
            if (!window.lastResult) return;
            const { schedule, staffList, stats } = window.lastResult;

            // Header: Staff, Class, [Date(Day)...], Total, Day, Night, Off
            const headers = ['Staff', 'Class'];
            schedule.forEach(d => {
                const dateNum = parseInt(d.date.slice(8)); // '03' -> 3
                const dayWeek = d.dow; // 'Sun', 'Mon' etc
                headers.push(`${dateNum}(${dayWeek})`);
            });
            headers.push('Total', 'Day', 'Night', 'Off');

            const rows = [headers.join(',')];

            staffList.forEach(s => {
                const st = stats[s.name];
                const offCount = st.history.filter(x => x === 'Off').length; // PostNight excluded
                // Count Day type (Day, Early, Late)
                const dayCount = st.history.filter(x => x === 'Day' || x === 'Early' || x === 'Late').length;

                const row = [s.name, s.class];

                st.history.forEach(type => {
                    let sym = ' ';
                    if (type === 'Night') sym = 'N';
                    if (type === 'PostNight') sym = 'P';
                    if (type === 'Off') sym = '/';
                    if (type === 'Early') sym = 'E';
                    if (type === 'Late') sym = 'L';
                    row.push(sym);
                });

                // Summary at end
                row.push(st.total, dayCount, st.nightMonth, offCount);

                rows.push(row.join(','));
            });

            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), rows.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'schedule_matrix.csv';
            a.click();
        }

        function isoWeekKey(d) {
            const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            const dayNum = (date.getUTCDay() + 6) % 7; date.setUTCDate(date.getUTCDate() - dayNum + 3);
            const firstThu = new Date(Date.UTC(date.getUTCFullYear(), 0, 4));
            const week = 1 + Math.round(((date - firstThu) / 86400000 - 3 + ((firstThu.getUTCDay() + 6) % 7)) / 7);
            return `${date.getUTCFullYear()}-W${String(week).padStart(2, '0')}`;
        }

        function exportICS() {
            if (!window.lastResult) return;
            const { schedule } = window.lastResult;

            let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//ShiftCrafter//JP//EN\n";

            schedule.forEach(day => {
                const dateStr = day.date.replace(/-/g, ''); // YYYYMMDD

                const addEvent = (list, summary) => {
                    list.forEach(name => {
                        ics += "BEGIN:VEVENT\n";
                        ics += `DTSTART;VALUE=DATE:${dateStr}\n`;
                        ics += `SUMMARY:${summary} - ${name}\n`;
                        ics += "END:VEVENT\n";
                    });
                };

                addEvent(day.assignments.day, "Day");
                addEvent(day.assignments.night, "Night");
                addEvent(day.assignments.early, "Early");
                addEvent(day.assignments.late, "Late");
                addEvent(day.assignments.off, "Off");
            });

            ics += "END:VCALENDAR";

            const blob = new Blob([ics], { type: 'text/calendar' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'schedule.ics';
            a.click();
        }

        // --- Events ---
        document.getElementById('btnGen').onclick = generateSchedule;
        document.getElementById('btnCsv').onclick = exportCSV;
        document.getElementById('btnIcs').onclick = exportICS;
        document.getElementById('btnReport').onclick = showReport;

        // Init
        // (function () {
        //     const now = new Date();
        //     document.getElementById('month').value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        // })();
    </script>
</body>

</html>